#!/usr/bin/env ruby

require 'bundler'
Bundler.require(:default)

module RedditKit
  class Client
    def middleware
      @middleware ||= Faraday::Builder.new do |builder|
        builder.use Faraday::Request::UrlEncoded
        builder.use RedditKit::Response::RaiseError
        builder.use RedditKit::Response::ParseJSON
        builder.use FaradayMiddleware::FollowRedirects
        builder.adapter :net_http
      end
    end
  end
end

module RedditKit
  class Comment
    def score
      attributes[:ups] - attributes[:downs]
    end
  end
end

# Should I write a comment about this ID?
def write?(p)
  id  = (p.respond_to? :id) ? p.id : p
  fn  = 'usage-log'
  l   = File.exists?(fn) && File.read(fn) || ''
  ids = l.split(',')
  ret = !ids.index(id)

  ids << id
  ids.uniq!
  File.open(fn, 'w') do |f|
    f.write(ids.join(','))
  end

  ret
end

def interesting(client)
  client.links('videos').results.select do |r|
    b = true
    b &&= r.num_comments < 70
    b &&= !r.sticky?
    b &&= r.url =~ %r{https?://[^/]+youtu\.?be}
    b
  end
end

def submitted(client, result)
  id   = result.url.match(%r{(?<=v=|/)[-_A-Z0-9]{11}}i).to_s
  url  = "http://youtube.com/watch?v=#{ id }"

  binding.pry if id == ''
  begin
    prev = client.search(url)
    prev.select do |r|
      next nil unless r
      r.permalink != result.permalink && r.num_comments > 90
    end.sort_by(&:num_comments).reverse.take(5) if prev
  rescue Errno::ETIMEDOUT
    retry if _r = (_r || 0) + 1 and _r < 4
    raise
  end
end

def leak_karma(client, rs)
  rs.map do |r|
    cs = client.comments(r)
    if cs.count > 20 # TOP_COMMENT_OF_YORE might interfere.
      cs.drop(1)
    else
      cs
    end
  end.
    flatten.compact.
    sort_by(&:score).reverse.
    first(5).
    sort_by { |c| c.inspect.length }.reverse. # *1
    first

  # 1 - Fishing for the punniest threads. Inspect does recursion,
  #     so the .inspect.length should =~ c * repliesAndSubreplies
end

def think(client, posts, oldies)
  posts.zip(oldies).map do |(p, oldlinks)|
    if oldlinks && oldlinks.count
      oldpost = leak_karma(client, oldlinks)
      if oldpost
        [p, oldpost, oldies]
      end
    end
  end.compact
end

def submit(client, p, c)
  client.submit_comment(p, c.body)
end

def log((p, c, o))
  def indent(stuff)
    ['', *stuff.split("\n")].join("\n  ")
  end

  if ENV["VERBOSE"]
    puts("#{ p.permalink } and #{ o.count } stuffs for it. Comment:" + indent(c.body))
  else
    puts "#{%x{ date }} | Submitting for #{ p.id }"
  end
end

def main(credentials)
  client  = RedditKit::Client.new *credentials
  posts   = interesting(client)
  write?("| #{ rand }\n") if posts.any?
  posts   = posts.select(&method(:write?))
  oldies  = posts.map do |p| submitted(client, p) end
  actions = think(client, posts, oldies)

  puts "posts  = #{ posts.count }"
  puts "oldies = #{ oldies.map { |o| o && o.length } }"
  actions.each do |(p, c, o)| submit(client, p, c) end.each(&method(:log))
end

raise unless ARGV.length == 2
main(ARGV.first(2))
